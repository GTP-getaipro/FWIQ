{
  "name": "<<<BUSINESS_NAME>>> Gmail AI Email Processing Workflow v<<<CONFIG_VERSION>>>",
  "nodes": [
    {
      "parameters": {
        "pollTimes": {
          "item": [
            {
              "mode": "custom",
              "cronExpression": "0 */2 * * * *"
            }
          ]
        },
        "simple": false,
        "filters": {
          "q": "in:inbox -(from:(*@<<<EMAIL_DOMAIN>>>))"
        },
        "options": {
          "downloadAttachments": true
        }
      },
      "type": "n8n-nodes-base.gmailTrigger",
      "typeVersion": 1.2,
      "position": [
        -800,
        400
      ],
      "id": "gmail-trigger",
      "name": "Email Trigger",
      "credentials": {
        "gmailOAuth2": {
          "id": "<<<CLIENT_GMAIL_CRED_ID>>>",
          "name": "<<<BUSINESS_NAME>>> Gmail"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Universal email data normalizer - works with Gmail, Outlook, Yahoo, etc.\nconst item = $json;\n\nfunction htmlToText(html) {\n  if (!html) return '';\n  return html\n    .replace(/<script[^>]*>([\\S\\s]*?)<\\/script>/gmi, '')\n    .replace(/<style[^>]*>([\\S\\s]*?)<\\/style>/gmi, '')\n    .replace(/<!--[\\s\\S]*?-->/g, '')\n    .replace(/<br\\s*\\/?>/gi, '\\n')\n    .replace(/<\\/(div|p|h[1-6]|li|tr)>/gi, '\\n')\n    .replace(/<[^>]+>/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>')\n    .replace(/&quot;/g, '\"')\n    .replace(/&#39;/g, \"'\")\n    .replace(/(\\n\\s*){3,}/g, '\\n\\n')\n    .trim();\n}\n\nconst messageBody = htmlToText(item.html || item.body?.content);\nconst messageId = item.headers?.['message-id'] || item.internetMessageId || item.id;\n\nreturn {\n  json: {\n    id: item.id,\n    threadId: item.threadId || item.conversationId,\n    subject: item.subject,\n    from: item.from?.value?.[0]?.address || item.from?.emailAddress?.address || null,\n    fromName: item.from?.value?.[0]?.name || item.from?.emailAddress?.name || null,\n    to: item.to?.value?.[0]?.address || item.toRecipients?.[0]?.emailAddress?.address || null,\n    toName: item.to?.value?.[0]?.name || item.toRecipients?.[0]?.emailAddress?.name || null,\n    date: item.date || item.receivedDateTime,\n    body: messageBody,\n    bodyHtml: item.html || item.body?.content,\n    labels: item.labelIds || [],\n    categories: item.categories || [],\n    provider: item.labelIds ? 'gmail' : (item.categories !== undefined ? 'outlook' : 'unknown'),\n    hasAttachments: !!(item.hasAttachments || (item.attachments?.length > 0)),\n    sizeEstimate: item.sizeEstimate || 0,\n    messageId: messageId\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -560,
        400
      ],
      "id": "prepare-email-data",
      "name": "Prepare Email Data"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Subject: {{ $json.subject }}\nFrom: {{ $json.from }}\nTo: {{ $json.to }}\nDate: {{ $now }}\nThread ID: {{ $json.threadId }}\nMessage ID: {{ $json.id }}\nProvider: {{ $json.provider }}\nHas Attachments: {{ $json.hasAttachments }}\n\nEmail Body:\n{{ $json.body }}",
        "options": {
          "systemMessage": "<<<AI_SYSTEM_MESSAGE>>>"
        }
      },
      "id": "ai-classifier",
      "name": "AI Master Classifier",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        -320,
        400
      ],
      "typeVersion": 1.8
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        -240,
        640
      ],
      "id": "openai-classifier-model-gmail",
      "name": "OpenAI Classifier Model",
      "credentials": {
        "openAiApi": {
          "id": "<<<CLIENT_OPENAI_CRED_ID>>>",
          "name": "<<<BUSINESS_NAME>>> OpenAI"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const outputs = [];\n\nconst aiItems = $input.all();\nconst emailItems = $('Prepare Email Data').all();\n\nfor (let i = 0; i < aiItems.length; i++) {\n  const aiOutput = aiItems[i].json.output;\n\n  try {\n    // Normalize to JSON string\n    let clean = typeof aiOutput === 'string' ? aiOutput.trim() : JSON.stringify(aiOutput);\n\n    // Remove markdown fences\n    clean = clean.replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/, '');\n\n    // Trim after last closing brace (common LLM quirk)\n    const lastBrace = clean.lastIndexOf('}');\n    if (lastBrace !== -1) clean = clean.slice(0, lastBrace + 1);\n\n    const parsedOutput = JSON.parse(clean);\n\n    // Attach email metadata\n    const email = emailItems[Math.min(i, emailItems.length - 1)]?.json || {};\n    if (email.id) parsedOutput.id = email.id;\n    if (email.threadId) parsedOutput.threadId = email.threadId;\n    if (email.provider) parsedOutput.provider = email.provider;\n\n    outputs.push({ json: { parsed_output: parsedOutput, error: false } });\n\n  } catch (e) {\n    // ERROR HANDLING: Critical for production\n    const email = emailItems[Math.min(i, emailItems.length - 1)]?.json || {};\n    outputs.push({\n      json: {\n        error: true,\n        id: email.id,\n        threadId: email.threadId,\n        provider: email.provider,\n        errorMessage: e.message,\n        originalOutput: aiOutput\n      }\n    });\n  }\n}\n\nreturn outputs;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -80,
        400
      ],
      "id": "parse-classification",
      "name": "Parse AI Classification"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "error-check-condition",
              "leftValue": "={{ $json.error }}",
              "rightValue": "\"true\"",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        160,
        400
      ],
      "id": "check-classification-errors",
      "name": "Check for Classification Errors"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "<<<SUPABASE_URL>>>/rest/v1/workflow_errors",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "<<<SUPABASE_ANON_KEY>>>"
            },
            {
              "name": "Authorization",
              "value": "Bearer <<<SUPABASE_ANON_KEY>>>"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"user_id\": \"<<<USER_ID>>>\",\n  \"business_name\": \"<<<BUSINESS_NAME>>>\",\n  \"error_type\": \"email_classification_error\",\n  \"email_from\": \"{{ $json.from }}\",\n  \"email_subject\": \"{{ $json.subject }}\",\n  \"email_date\": \"{{ $json.date }}\",\n  \"thread_id\": \"{{ $json.threadId }}\",\n  \"message_id\": \"{{ $json.id }}\",\n  \"error_message\": \"{{ $json.error || 'Unknown classification error' }}\",\n  \"created_at\": \"{{ $now.toISO() }}\"\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        400,
        160
      ],
      "id": "log-error-to-supabase",
      "name": "Log Error to Supabase",
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const parsed = $json.parsed_output;\nconst provider = parsed.provider || 'gmail';\n\n// Dynamic label mapping from database\nconst labelMap = <<<LABEL_MAP>>>;\n\n// Helper function to normalize category names\nfunction normalizeCategory(category) {\n  if (!category) return null;\n  return category.toString().toUpperCase().trim();\n}\n\n// Helper function to find label with fuzzy matching\nfunction findLabel(category, labelMap) {\n  if (!category) return null;\n  \n  const normalized = normalizeCategory(category);\n  \n  // Try exact match first\n  const exactIdMatch = labelMap[normalized]?.id;\n  if (exactIdMatch) {\n    return exactIdMatch;\n  }\n  \n  // Try case-insensitive match (on keys)\n  const caseInsensitiveKey = Object.keys(labelMap).find(key => \n    key.toUpperCase() === normalized\n  );\n  if (caseInsensitiveKey) {\n    return labelMap[caseInsensitiveKey].id;\n  }\n  \n  // Try partial match (on keys)\n  const partialMatchKey = Object.keys(labelMap).find(key => \n    key.toUpperCase().includes(normalized) || \n    normalized.includes(key.toUpperCase())\n  );\n  if (partialMatchKey) {\n    return labelMap[partialMatchKey].id;\n  }\n  \n  return null;\n}\n\n// CRITICAL FIX: Validate label IDs before using them\nfunction validateLabelId(labelId) {\n  if (!labelId) return false;\n  \n  // Check if it's a valid Gmail label ID format\n  if (typeof labelId === 'string' && labelId.startsWith('Label_')) {\n    return true;\n  }\n  \n  // Check if it's a valid Outlook folder ID format\n  if (typeof labelId === 'string' && labelId.startsWith('AAMkAD')) {\n    return true;\n  }\n  \n  return false;\n}\n\nconst labels = [];\nconst debugInfo = {\n  primaryCategory: parsed.primary_category,\n  secondaryCategory: parsed.secondary_category,\n  tertiaryCategory: parsed.tertiary_category,\n  foundLabelIds: [],\n  finalLabels: [],\n  labelMapSize: Object.keys(labelMap).length\n};\n\n// Add primary category label with improved matching\nconst primaryLabelId = findLabel(parsed.primary_category, labelMap);\nif (primaryLabelId && validateLabelId(primaryLabelId)) {\n  labels.push(primaryLabelId);\n  debugInfo.foundLabelIds.push(primaryLabelId);\n} else {\n  console.warn(`‚ö†Ô∏è Invalid or missing primary label for: ${parsed.primary_category}`);\n}\n\n// Add secondary category label\nif (parsed.secondary_category) {\n  const key = `${parsed.primary_category}/${parsed.secondary_category}`;\n  const secondaryLabelId = findLabel(key, labelMap);\n  if (secondaryLabelId && validateLabelId(secondaryLabelId)) {\n    labels.push(secondaryLabelId);\n    debugInfo.foundLabelIds.push(secondaryLabelId);\n  } else {\n    console.warn(`‚ö†Ô∏è Invalid or missing secondary label for: ${key}`);\n  }\n}\n\n// Add tertiary category label\nif (parsed.tertiary_category) {\n  const key = `${parsed.primary_category}/${parsed.secondary_category}/${parsed.tertiary_category}`;\n  const tertiaryLabelId = findLabel(key, labelMap);\n  if (tertiaryLabelId && validateLabelId(tertiaryLabelId)) {\n    labels.push(tertiaryLabelId);\n    debugInfo.foundLabelIds.push(tertiaryLabelId);\n  } else {\n    console.warn(`‚ö†Ô∏è Invalid or missing tertiary label for: ${key}`);\n  }\n}\n\n// Remove duplicates and ensure we have valid label IDs\nconst uniqueLabels = [...new Set(labels)].filter(labelId => validateLabelId(labelId));\n\n// CRITICAL FIX: Fallback to MISC label ID if no valid labels found\nconst miscLabelId = labelMap['MISC']?.id || null;\nconst validMiscLabel = miscLabelId && validateLabelId(miscLabelId) ? miscLabelId : null;\n\nconst finalLabels = uniqueLabels.length > 0 ? uniqueLabels : (validMiscLabel ? [validMiscLabel] : []);\ndebugInfo.finalLabels = finalLabels;\n\n// Log debug information\nconsole.log('üîç Label Processing Debug:', debugInfo);\n\n// If no valid labels found, log warning and return empty array\nif (finalLabels.length === 0) {\n  console.warn('‚ö†Ô∏è No valid labels found for email classification. Email will not be labeled.');\n  console.warn('üìã Available labels in map:', Object.keys(labelMap));\n  console.warn('üìã Parsed categories:', {\n    primary: parsed.primary_category,\n    secondary: parsed.secondary_category,\n    tertiary: parsed.tertiary_category\n  });\n}\n\nreturn {\n  json: {\n    ...parsed,\n    labelsToApply: finalLabels,\n    categoriesToApply: finalLabels.map(l => {\n      // Find category name from label ID for debug purposes\n      const entry = Object.entries(labelMap).find(([k, v]) => v.id === l);\n      return entry ? entry[0] : l;\n    }),\n    provider: provider,\n    debugInfo: debugInfo\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        400
      ],
      "id": "generate-label-mappings",
      "name": "Generate Label Mappings"
    },
    {
      "parameters": {
        "operation": "addLabels",
        "messageId": "={{ $json.id }}",
        "labelIds": "={{ $json.labelsToApply }}"
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        640,
        400
      ],
      "id": "apply-gmail-labels",
      "name": "Apply Gmail Labels",
      "credentials": {
        "gmailOAuth2": {
          "id": "<<<CLIENT_GMAIL_CRED_ID>>>",
          "name": "<<<BUSINESS_NAME>>> Gmail"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "can-reply-condition",
              "leftValue": "={{ $json.ai_can_reply }}",
              "rightValue": "\"true\"",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        880,
        400
      ],
      "id": "check-can-reply",
      "name": "Can AI Reply?"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "<<<SUPABASE_URL>>>/functions/v1/style-memory",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "supabaseApi",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "=Bearer <<<SUPABASE_ANON_KEY>>>"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  userId: \"<<<USER_ID>>>\",\n  category: $json.parsed_output.primary_category,\n  limit: 5\n}) }}",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1120,
        240
      ],
      "id": "fetch-voice-context",
      "name": "Fetch Voice Context (Optional)",
      "credentials": {
        "supabaseApi": {
          "id": "<<<CLIENT_SUPABASE_CRED_ID>>>",
          "name": "Supabase FWIQ"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "mode": "combine",
        "combineBy": "combineByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        1360,
        400
      ],
      "id": "merge-email-voice-context",
      "name": "Merge Email + Voice Context"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Prepare context for AI reply agent\nconst emailData = $('Prepare Email Data').first()?.json || {};\nconst classification = $json.parsed_output || {};\nconst voiceContext = $('Fetch Voice Context (Optional)').first()?.json || {};\n\n// Handle optional voice training data\nlet voiceExamples = '';\nlet voiceMetrics = '';\n\nif (voiceContext && voiceContext.examples && voiceContext.examples.length > 0) {\n  voiceExamples = `RECENT STYLE EXAMPLES (How you typically write):\n${'‚îÄ'.repeat(60)}\n${voiceContext.examples.map((ex, i) => `Example ${i+1}:\\n${ex}`).join('\\n\\n')}`;\n  \n  if (voiceContext.metrics) {\n    voiceMetrics = `\\nVOICE METRICS:\nFormality: ${voiceContext.metrics.formality || 'N/A'}\nEmpathy: ${voiceContext.metrics.empathy || 'N/A'}\nDirectness: ${voiceContext.metrics.directness || 'N/A'}`;\n  }\n} else {\n  voiceExamples = `VOICE TRAINING: Not yet available (will learn from your sent emails)`;\n}\n\nreturn {\n  json: {\n    emailSubject: emailData.subject,\n    emailFrom: emailData.from,\n    emailBody: emailData.body,\n    threadId: emailData.threadId,\n    classification: classification,\n    voiceExamples: voiceExamples,\n    voiceMetrics: voiceMetrics,\n    hasVoiceTraining: !!(voiceContext && voiceContext.examples && voiceContext.examples.length > 0)\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1600,
        400
      ],
      "id": "prepare-draft-context",
      "name": "Prepare Draft Context"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=EMAIL TO REPLY TO:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nSubject: {{ $json.emailSubject }}\nFrom: {{ $json.emailFrom }}\nBody: {{ $json.emailBody }}\n\nCLASSIFICATION:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nCategory: {{ $json.classification.primary_category }}\nSubcategory: {{ $json.classification.secondary_category }}\nSummary: {{ $json.classification.summary }}\nConfidence: {{ $json.classification.confidence }}\n\n{{ $json.voiceExamples }}\n{{ $json.voiceMetrics }}\n\nTHREAD CONTEXT:\n‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\nThread ID: {{ $json.threadId }}",
        "options": {
          "systemMessage": "<<<BEHAVIOR_REPLY_PROMPT>>>"
        }
      },
      "id": "ai-reply",
      "name": "AI Draft Reply Agent",
      "type": "@n8n/n8n-nodes-langchain.agent",
      "position": [
        1840,
        400
      ],
      "typeVersion": 1.8
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.7
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1920,
        640
      ],
      "id": "openai-reply-model-gmail",
      "name": "OpenAI Draft Model",
      "credentials": {
        "openAiApi": {
          "id": "<<<CLIENT_OPENAI_CRED_ID>>>",
          "name": "<<<BUSINESS_NAME>>> OpenAI"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Prepare Email Data').first().json.threadId }}",
        "contextWindowLength": 10
      },
      "id": "conversation-memory",
      "name": "Conversation Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "position": [
        2040,
        640
      ],
      "typeVersion": 1.3
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Format reply as HTML for email\nreturn {\n  json: {\n    output: $json.output.replace(/\\n/g, '<br>')\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2160,
        400
      ],
      "id": "format-reply-html",
      "name": "Format Reply as HTML"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "//  DYNAMIC MANAGER ROUTING LOGIC\n// Determines which manager should receive this email based on:\n// 1. Name detection (highest priority)\n// 2. Role-category matching (medium priority)\n// 3. MANAGER category keyword analysis (detailed priority)\n\nconst classification = $json.parsed_output || $json;\nconst emailData = $('Prepare Email Data').first()?.json || {};\n\n// <<<MANAGERS_CONFIG>>> will be injected during deployment\nconst managers = <<<MANAGERS_CONFIG>>>;\n\nif (!managers || managers.length === 0) {\n  return [{\n    json: {\n      ...classification,\n      matched_manager: null,\n      routing_decision: {\n        reason: 'no_managers_configured',\n        matched_by: null,\n        matched_roles: [],\n        confidence: 0\n      }\n    }\n  }];\n}\n\n// Role configuration with routing rules\nconst ROLE_CONFIG = {\n  sales_manager: {\n    categories: ['SALES'],\n    keywords: ['price', 'quote', 'buy', 'purchase', 'how much', 'cost', 'pricing', 'payment', 'financing'],\n    weight: 1.0\n  },\n  service_manager: {\n    categories: ['SUPPORT', 'URGENT'],\n    keywords: ['repair', 'fix', 'broken', 'not working', 'appointment', 'emergency', 'urgent', 'help', 'issue'],\n    weight: 1.0\n  },\n  operations_manager: {\n    categories: ['MANAGER', 'SUPPLIERS'],\n    keywords: ['vendor', 'supplier', 'hiring', 'internal', 'partnership', 'contract', 'order'],\n    weight: 0.8\n  },\n  support_lead: {\n    categories: ['SUPPORT'],\n    keywords: ['help', 'question', 'how to', 'parts', 'chemicals', 'advice', 'information'],\n    weight: 0.7\n  },\n  owner: {\n    categories: ['MANAGER', 'URGENT'],\n    keywords: ['strategic', 'legal', 'partnership', 'media', 'complaint', 'escalation'],\n    weight: 0.9\n  }\n};\n\nconst emailBody = (emailData.body || '').toLowerCase();\nconst emailSubject = (emailData.subject || '').toLowerCase();\nconst fullText = `${emailSubject} ${emailBody}`;\n\n// PRIORITY 1: Name Detection (Highest)\nfor (const manager of managers) {\n  const nameLower = manager.name.toLowerCase();\n  const firstName = nameLower.split(' ')[0];\n  \n  if (fullText.includes(nameLower) || fullText.includes(firstName)) {\n    console.log(`‚úÖ PRIORITY 1: Name detected - Routing to ${manager.name}`);\n    return [{\n      json: {\n        ...classification,\n        matched_manager: manager,\n        routing_decision: {\n          reason: 'name_detected',\n          matched_by: 'direct_mention',\n          matched_roles: manager.roles || [],\n          confidence: 1.0,\n          detection: `Email mentions \"${manager.name}\"`\n        }\n      }\n    }];\n  }\n}\n\n// PRIORITY 2: Category + Role Matching\nconst primaryCategory = classification.primary_category;\nlet bestMatch = null;\nlet bestScore = 0;\n\nfor (const manager of managers) {\n  const managerRoles = Array.isArray(manager.roles) ? manager.roles : [manager.role].filter(Boolean);\n  \n  if (managerRoles.length === 0) continue;\n  \n  let score = 0;\n  let matchedRoles = [];\n  \n  // Check each role the manager has\n  for (const roleId of managerRoles) {\n    const roleConfig = ROLE_CONFIG[roleId];\n    if (!roleConfig) continue;\n    \n    // Category match\n    if (roleConfig.categories.includes(primaryCategory)) {\n      score += roleConfig.weight * 10; // High weight for category match\n      matchedRoles.push(roleId);\n      \n      // Keyword boost (only if category matches)\n      for (const keyword of roleConfig.keywords) {\n        if (fullText.includes(keyword)) {\n          score += 0.5; // Keyword adds confidence\n        }\n      }\n    }\n  }\n  \n  if (score > bestScore) {\n    bestScore = score;\n    bestMatch = {\n      manager: manager,\n      matchedRoles: matchedRoles,\n      score: score\n    };\n  }\n}\n\nif (bestMatch && bestScore > 0) {\n  const roleLabels = bestMatch.matchedRoles.map(r => r.replace(/_/g, ' ')).join(' + ');\n  console.log(`‚úÖ PRIORITY 2: Role match - Routing to ${bestMatch.manager.name} (${roleLabels}, score: ${bestScore})`);\n  return [{\n    json: {\n      ...classification,\n      matched_manager: bestMatch.manager,\n      routing_decision: {\n        reason: 'role_category_match',\n        matched_by: 'role_routing',\n        matched_roles: bestMatch.matchedRoles,\n        confidence: Math.min(bestScore / 10, 1.0),\n        detection: `Category \"${primaryCategory}\" matches ${roleLabels}`\n      }\n    }\n  }];\n}\n\n// PRIORITY 3: MANAGER Category Keyword Analysis\nif (primaryCategory === 'MANAGER') {\n  console.log('üìä MANAGER category detected - analyzing keywords for specific manager match...');\n  \n  let keywordScores = managers.map(manager => {\n    const managerRoles = Array.isArray(manager.roles) ? manager.roles : [manager.role].filter(Boolean);\n    let score = 0;\n    let matchedKeywords = [];\n    \n    for (const roleId of managerRoles) {\n      const roleConfig = ROLE_CONFIG[roleId];\n      if (!roleConfig) continue;\n      \n      for (const keyword of roleConfig.keywords) {\n        if (fullText.includes(keyword)) {\n          score += 1;\n          matchedKeywords.push(keyword);\n        }\n      }\n    }\n    \n    return { manager, score, matchedKeywords };\n  }).filter(m => m.score > 0);\n  \n  // Sort by score\n  keywordScores.sort((a, b) => b.score - a.score);\n  \n  if (keywordScores.length > 0 && keywordScores[0].score > 0) {\n    const topMatch = keywordScores[0];\n    const roleLabels = (topMatch.manager.roles || []).map(r => r.replace(/_/g, ' ')).join(' + ');\n    console.log(`‚úÖ PRIORITY 3: Keyword match - Routing to ${topMatch.manager.name} (keywords: ${topMatch.matchedKeywords.join(', ')})`);\n    return [{\n      json: {\n        ...classification,\n        matched_manager: topMatch.manager,\n        routing_decision: {\n          reason: 'manager_keyword_analysis',\n          matched_by: 'keyword_scoring',\n          matched_roles: topMatch.manager.roles || [],\n          confidence: Math.min(topMatch.score / 5, 0.8),\n          detection: `Keywords matched: ${topMatch.matchedKeywords.join(', ')}`,\n          keywordScore: topMatch.score\n        }\n      }\n    }];\n  }\n}\n\n// PRIORITY 4: Fallback to first manager (if only one) or unassigned\nif (managers.length === 1) {\n  console.log(`‚ö†Ô∏è FALLBACK: Only one manager configured - Routing to ${managers[0].name}`);\n  return [{\n    json: {\n      ...classification,\n      matched_manager: managers[0],\n      routing_decision: {\n        reason: 'single_manager_fallback',\n        matched_by: 'default',\n        matched_roles: managers[0].roles || [],\n        confidence: 0.5\n      }\n    }\n  }];\n}\n\nconsole.log('‚ùå No manager match found - Email will not be forwarded');\nreturn [{\n  json: {\n    ...classification,\n    matched_manager: null,\n    routing_decision: {\n      reason: 'no_match_found',\n      matched_by: null,\n      matched_roles: [],\n      confidence: 0,\n      note: 'Email labeled but not routed to specific manager'\n    }\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2640, 400],
      "id": "route-to-manager",
      "name": "Route to Manager (Dynamic)"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Build email body for manager forwarding with AI draft\nconst manager = $json.matched_manager || {};\nconst managerEmail = manager?.email;\nconst aiCanReply = $json.ai_can_reply;\nconst routing = $json.routing_decision || {};\n\nconst originalEmail = $('Prepare Email Data').first().json;\nconst aiDraft = aiCanReply && $('AI Draft Reply Agent').item?.json?.output ? $('AI Draft Reply Agent').item.json.output : null;\n\nlet forwardBody = '';\n\nif (aiDraft) {\n  forwardBody = `ü§ñ AI SUGGESTED RESPONSE (Review & Approve):\\n${'='.repeat(60)}\\n${aiDraft.replace(/<br>/g, '\\n')}\\n${'='.repeat(60)}\\n\\n‚úÖ AI Confidence: ${Math.round($json.confidence * 100)}%\\n‚úÖ Classification: ${$json.primary_category}${$json.secondary_category ? ' > ' + $json.secondary_category : ''}\\n‚úÖ Routed to you as: ${routing?.matched_roles?.join(' + ') || manager?.roles?.join(' + ') || 'Manager'}\\n\\nüí° QUICK ACTIONS:\\n‚îú‚îÄ ‚úÖ Approve: Reply to customer with this draft\\n‚îú‚îÄ ‚úèÔ∏è Edit: Modify before sending\\n‚îî‚îÄ ‚ùå Reject: Write your own response\\n\\n${'-'.repeat(60)}\\n\\n--- ORIGINAL CUSTOMER EMAIL ---\\nFrom: ${originalEmail.from}\\nTo: ${originalEmail.to}\\nSubject: ${originalEmail.subject}\\nDate: ${originalEmail.date || new Date().toISOString()}\\n\\n${originalEmail.body}\\n\\n${'-'.repeat(60)}\\n\\nFloWorx Email Processing System\\nManaged by ${manager?.name || 'Your Team'}`;\n} else {\n  forwardBody = `‚ö†Ô∏è AI COULD NOT GENERATE RESPONSE\\n\\n‚ùå Reason: Low confidence or requires human judgment\\n‚úÖ Classification: ${$json.primary_category}${$json.secondary_category ? ' > ' + $json.secondary_category : ''}\\n‚úÖ Confidence: ${Math.round($json.confidence * 100)}%\\n‚úÖ Routed to you as: ${routing?.matched_roles?.join(' + ') || 'Manager'}\\n\\nüí° This email requires your personal response.\\n\\n${'-'.repeat(60)}\\n\\n--- ORIGINAL CUSTOMER EMAIL ---\\nFrom: ${originalEmail.from}\\nSubject: ${originalEmail.subject}\\n\\n${originalEmail.body}\\n\\n${'-'.repeat(60)}\\n\\nFloWorx Email Processing System\\nManaged by ${manager?.name || 'Your Team'}`;\n}\n\nreturn [{\n  json: {\n    shouldForward: !!(managerEmail && managerEmail.trim() !== '' && managerEmail.includes('@')),\n    forwardTo: managerEmail,\n    forwardSubject: `Fwd: ${originalEmail.subject}`,\n    forwardBody: forwardBody,\n    hasAIDraft: !!aiDraft,\n    managerName: manager?.name || 'Manager',\n    originalMessageId: originalEmail.id\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2880, 400],
      "id": "build-forward-body",
      "name": "Build Forward Email Body"
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.shouldForward}}",
              "value2": true
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [3120, 400],
      "id": "if-manager-email",
      "name": "IF Manager Has Email"
    },
    {
      "parameters": {
        "resource": "message",
        "operation": "send",
        "sendTo": "={{$json.forwardTo}}",
        "subject": "={{$json.forwardSubject}}",
        "emailType": "text",
        "message": "={{$json.forwardBody}}",
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [3360, 320],
      "id": "forward-to-manager",
      "name": "Forward to Manager (Gmail)",
      "credentials": {
        "gmailOAuth2": {
          "id": "<<<CLIENT_GMAIL_CRED_ID>>>",
          "name": "<<<BUSINESS_NAME>>> Gmail"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "resource": "draft",
        "subject": "={{ $('Prepare Email Data').first().json.subject }}",
        "emailType": "html",
        "message": "={{ $json.output }}",
        "options": {
          "replyTo": "={{ /@(<<<EMAIL_DOMAIN>>>)$/i.test($('Prepare Email Data').first().json.from) ? $('Prepare Email Data').first().json.to : $('Prepare Email Data').first().json.from }}",
          "threadId": "={{ $('Prepare Email Data').first().json.threadId }}",
          "sendTo": "={{ /@(<<<EMAIL_DOMAIN>>>)$/i.test($('Prepare Email Data').first().json.from) ? $('Prepare Email Data').first().json.to : $('Prepare Email Data').first().json.from }}"
        }
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        2400,
        400
      ],
      "id": "create-gmail-draft",
      "name": "Create Gmail Draft",
      "credentials": {
        "gmailOAuth2": {
          "id": "<<<CLIENT_GMAIL_CRED_ID>>>",
          "name": "<<<BUSINESS_NAME>>> Gmail"
        }
      }
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "// Calculate performance metrics\nconst classificationTime = 3; // minutes to classify email\nconst responseTime = 8; // minutes to draft response\nconst receptionistHourlyRate = 25;\n\nconst emailsProcessed = 1;\nconst aiCanReply = $json.ai_can_reply || false;\n\n// Different time savings based on email type:\n// - Labeled only (ai_can_reply: false): 3 minutes\n// - Labeled + Drafted (ai_can_reply: true): 3 + 8 = 11 minutes\nconst avgMinutesPerEmail = aiCanReply ? (classificationTime + responseTime) : classificationTime;\nconst timeSavedHours = +(emailsProcessed * avgMinutesPerEmail / 60).toFixed(2);\nconst moneySaved = +(timeSavedHours * receptionistHourlyRate).toFixed(2);\n\nreturn {\n  json: {\n    date: new Date().toISOString().slice(0, 10),\n    type: aiCanReply ? 'Drafting' : 'Labeling',\n    emailsProcessed,\n    avgMinutesPerEmail,\n    timeSavedHours,\n    receptionistHourlyRate,\n    moneySaved,\n    userId: '<<<USER_ID>>>'\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        640
      ],
      "id": "calculate-metrics",
      "name": "Calculate Performance Metrics"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "<<<SUPABASE_URL>>>/rest/v1/performance_metrics",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "<<<SUPABASE_ANON_KEY>>>"
            },
            {
              "name": "Authorization",
              "value": "Bearer <<<SUPABASE_ANON_KEY>>>"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  user_id: \"<<<USER_ID>>>\",\n  metric_date: $json.date,\n  metric_name: \"email_processing\",\n  metric_value: $json.emailsProcessed,\n  dimensions: { type: $json.type, timeSavedHours: $json.timeSavedHours, moneySaved: $json.moneySaved, avgMinutesPerEmail: $json.avgMinutesPerEmail, receptionistHourlyRate: $json.receptionistHourlyRate, workflow: 'email-automation' }\n}) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        880,
        640
      ],
      "id": "save-metrics",
      "name": "Save Performance Metrics",
      "continueOnFail": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "<<<SUPABASE_URL>>>/rest/v1/ai_draft_learning",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "apikey",
              "value": "<<<SUPABASE_ANON_KEY>>>"
            },
            {
              "name": "Authorization",
              "value": "Bearer <<<SUPABASE_ANON_KEY>>>"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Prefer",
              "value": "return=minimal"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({\n  user_id: \"<<<USER_ID>>>\",\n  thread_id: $('Prepare Email Data').first().json.threadId,\n  email_id: $('Prepare Email Data').first().json.id,\n  original_email: $('Prepare Email Data').first().json.body,\n  ai_draft: $('Format Reply as HTML').first().json.output,\n  classification: $('Parse AI Classification').first().json.parsed_output,\n  confidence_score: $('Parse AI Classification').first().json.parsed_output.confidence,\n  model_used: \"gpt-4o-mini\"\n}) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2000,
        272
      ],
      "id": "save-to-learning-db",
      "name": "Save AI Draft for Learning",
      "continueOnFail": true
    }
  ],
  "connections": {
    "Email Trigger": {
      "main": [
        [
          {
            "node": "Prepare Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Email Data": {
      "main": [
        [
          {
            "node": "AI Master Classifier",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Master Classifier": {
      "main": [
        [
          {
            "node": "Parse AI Classification",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Classifier Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Master Classifier",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Classification": {
      "main": [
        [
          {
            "node": "Check for Classification Errors",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Classification Errors": {
      "main": [
        [
          {
            "node": "Log Error to Supabase",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Generate Label Mappings",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Label Mappings": {
      "main": [
        [
          {
            "node": "Apply Gmail Labels",
            "type": "main",
            "index": 0
          },
          {
            "node": "Calculate Performance Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Apply Gmail Labels": {
      "main": [
        [
          {
            "node": "Can AI Reply?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Can AI Reply?": {
      "main": [
        [
          {
            "node": "Fetch Voice Context (Optional)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Merge Email + Voice Context",
            "type": "main",
            "index": 1
          }
        ],
        []
      ]
    },
    "Fetch Voice Context (Optional)": {
      "main": [
        [
          {
            "node": "Merge Email + Voice Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Email + Voice Context": {
      "main": [
        [
          {
            "node": "Prepare Draft Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Draft Context": {
      "main": [
        [
          {
            "node": "AI Draft Reply Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Draft Reply Agent": {
      "main": [
        [
          {
            "node": "Format Reply as HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Draft Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Draft Reply Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Conversation Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Draft Reply Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Format Reply as HTML": {
      "main": [
        [
          {
            "node": "Create Gmail Draft",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Gmail Draft": {
      "main": [
        [
          {
            "node": "Save AI Draft for Learning",
            "type": "main",
            "index": 0
          },
          {
            "node": "Route to Manager (Dynamic)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route to Manager (Dynamic)": {
      "main": [
        [
          {
            "node": "Build Forward Email Body",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Forward Email Body": {
      "main": [
        [
          {
            "node": "IF Manager Has Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Manager Has Email": {
      "main": [
        [
          {
            "node": "Forward to Manager (Gmail)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Calculate Performance Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Forward to Manager (Gmail)": {
      "main": [
        [
          {
            "node": "Calculate Performance Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Calculate Performance Metrics": {
      "main": [
        [
          {
            "node": "Save Performance Metrics",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  }
}